// amount of interrupts per second generated by counter 1
// we want a pulse of 10 ms, so a frequency of 100 Hz / 100 interrupts/s
#define COUNTER1_INT_PS		100
#define F_CPU				16000000
#define MYUBRR				103

#define ECHO_PIN			PIND3		// INT0
#define TRIGGER_PIN			PINB0		// PIN 8

#include <asf.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <functions.h>

volatile int counter_l;
volatile int counter_h;
volatile int echorecv;

int main(void){
	HCSR04_init_pins();				// initialize HCSR04 pins
	HCSR04_counter_init();			// initialize HCSR04 counter
	
	interrupts_init();				// initialize interrupts
	USART_Init(MYUBRR);				// enable USART
	
	echorecv = 0;					// clear echo received variable
	
	init_debug();
	
	while(1){
		HCSR04_get_distance();
	}
}

void HCSR04_get_distance(){
	HCSR04_send_pulse();			// send a pulse
	while(echorecv != 1);			// wait for the echo to be sent back
	_delay_ms(500);
}

void init_debug(){								// temporary debug function
	DDRD |= (1<<PIND4) | (1<<PIND5) | (1<<PIND6);	// init LEDs for use as visual debug
}

void interrupts_init(){
	sei();							// enable global interrupt flag
	EICRA = (0<<ISC11)|(1<<ISC10);	// set the external interrupt to trigger any logical change
	EIMSK = (1<<INT1);				// enable external interrupt on INT1
}

// pulls the trigger high for 15 ms, making the HCSR04 send a pulse
void HCSR04_send_pulse(){
	PORTB = (1<<TRIGGER_PIN);		// set trigger high
	_delay_ms(15);					// wait 15 ms (trigger has to be at least 10ms)
	PORTB = (0<<TRIGGER_PIN);		// set trigger low
	
}

// initialize the HCSR04 pins
void HCSR04_init_pins(){
	// laag = input
	// hoog = output
	DDRD = (0<<ECHO_PIN);		// PIND3 -> INT1
	DDRB = (1<<TRIGGER_PIN);	// PINB0
}

// initialize the clock for the HC-SR04
// uses TCCR1A
void HCSR04_counter_init(){
	TCCR1A = 0x00;				// use standard settings
	TCCR1B = 0x00;			
	TCCR1C = 0x00;				// use standard settings
}

// triggers on a logical change on INT1
ISR (INT1_vect){
	if (TCCR1B == 0x00){		// check if timer is disabled
		echorecv = 0;			// set echo received flag low
		
		TCNT1L = 0x00;			// clear low counter bits
		TCNT1H = 0x00;			// clear high counter bits
		
		counter_l = 0x00;		// clear low counter bits saving variable
		counter_h = 0x00;		// clear high counter bits saving variable
		
		TCCR1B = (1<<CS10);		// enable timer
		return;
	}
	if (TCCR1B == 0x01){		// check if the timer is enabled
		counter_l = TCNT1L;		// save low counter bits saving variable
		counter_h = TCNT1H;		// save high counter bits saving variable

		USART_Transmit(TCNT1H);
		USART_Transmit(TCNT1L);

		
		TCNT1L = 0x00;			// clear low counter bits
		TCNT1H = 0x00;			// clear high counter bits
		
		echorecv = 1;			// set echo received flag high
		return;
	}
}

void USART_Init(unsigned int ubrr){
	// set baud rate
	UBRR0H = (unsigned char)(ubrr>>8);
	UBRR0L = (unsigned char)ubrr;
	
	// enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
	
	// set frame format: 8data, 2 stop bit
	UCSR0C = (1<<USBS0)|(3<<UCSZ00);
}

void USART_Transmit(unsigned char data){
	while (!(UCSR0A & (1<<UDRE0)));
	UDR0 = data;
}
